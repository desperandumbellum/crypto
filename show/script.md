### slide
Доброе утро! Сейчас речь пойдёт о так называемой атаке Spectre. Наверняка многие из Вас слышали о ней или о схожей атаке Meltdown. Spectre основан на некоторых уязвимостях в устройстве современных процессоров.

### slide
Первая часть доклада будет содержать теоретическое объяснение этих уязвимостей. Во второй части будет небольшая демонстрация и пояснение кода. Для лучшего понимания давайте кратко рассмотрим основные концепции.

### slide
Для начала давайте посмотрим на вычислительную систему абстрактно. Задача любой вычислительной системы --- обработка данных. Эти самые данные нужно где-то хранить и, соответственно, обращаться к ним в случае надобности. Операции над этими данными производит процессор. Как вы знаете, процессор - это мозг всех наших устройств. Процессор отвечает за выполнение всех инструкций, заданных программистом. И, конечно же, важным параметром процессора является скорость его работы.

Также важно сказать пару слов о памяти. В наших устройствах есть три типа памяти: диск, затем основная системная память, также называемая оперативной памятью, и, наконец, кэш-память в процессоре.

Для понимания сути демонстрируемой уязвимости этих знаний о процессоре будет достаточно, зато нелишним будет подробнее изучить устройтва памяти. Примечателен тот факт, что чем больше данных устройство способно хранить, тем больше время доступа к этим самым данным. На текущий момент применительно к вычислительным комплексам хорошо себя зарекомендовала иерархическая структура памяти. При таком построении данные хранятся преимущественно в большой и медленной памяти, "далекой" от процессора. При обращении к ним нужная часть переносится ближе к процессору и сохраняется в памяти, которая чуть быстрее и дороже. Этот процесс можно практически неограниченно продолжать, добавляя все более быструю память на верхушку иерархии и все более медленную --- в основу этой пирамиды.

~~Описанный подход работает в силу так называемого "принципа локальности". Большинство программ не оперируют со всеми доступными им данными одновременно -- обычно программа работает с некоторым подмножеством данных, и затем переходит к другому подмножеству. Это позволяет "загрузить" необходимый кусок данных в быструю, но маленькую память, и работать с ними быстрее, чем обращясь напрямую к медленную память. В целом это збс и работает. А еще это порочный круг -- из-за проги делают кэши, а из-за кэшей пишут кэш-френдли проги.~~

### slide
Это была абстракция, но как на счет некоторой конкретики? Мы остановились на трехуровневой модели памяти. В порядке уменьшения времени доступа: диск, затем основная --- оперативна память, и кэш. На таблице представлены характерные времена операций, связанных с вводом-выводом данных, и некоторые сопутствующие операции, приведённые для сравнения. Обратите внимание, как растет время доступа с удалением от процессора.

Так как обращение к RAM на пару порядков больше типичного времени выполнения инструкции, люди добавили небольшой кэш (L1 и L2 на картинке) на кристалл процессора для очень быстрого доступа к данным, с которыми он работает в данный момент. Каждый раз, когда процессор что-то достаёт из основной памяти, он копирует это значение в кэш и в следующий раз прочитает информацию уже из кэша с большей скоростью.

### slide
Вернемся к быстродействию. Стремясь улучшить быстродействие процессора, архитекторы процессоров однажды пришли к так назваемому "спекулятивному" исполнению. Что же это такое? Алгоритмы обработки данных редко бывают последовательными -- практически в любой программе можно встретить условные переходы: инструкции, которые необходимо исполнить далее, зависят от какого-то условия. Представьте, что у вас есть какое-то условие в коде, зависящее от данных, которые отстутствуют в кэшах. Процессор вынужден запросить эти данные из основной, медленной памяти. Однако вместо того чтобы ждать пока данные будут доставлены, процессор попытается угадать ветвь исполнения, основываясь на предыстории. Когда же данные придут из RAM, процессор может проверить, угадал ли он. Если да, то он "опередил себя" на сотню операций, если нет --- он "выбросит" полученный результат и пойдет по нужному пути, не сильно потерв в производительности.

Прекрасная технология, но есть один нюанс. Спекулятивно вычисляя результат, процессор обращается к памяти, которая может быть недоступна пользователю при нормальном выполнении программы. Это открывает целый спектр атак типа Spectre.

### slide
Чуть подробнее расскажу о варианте, который был нами реализован.
Существует целый ряд аттак по стороннему каналу, при которых данные добываются при помощи наблюдений за поведением системы. В частности, нас будет интересовать так называемая timing attack, которая вместе со спектром образует опасное оружие. 

Представьте, что вы аналитик, который измеряет время доступа процессора к некоторой памяти. Как уже отмечалось, если процессор недавно уже обращался к запрашиваемому участку памяти, то данные будут храниться в кэше, значит время доступа к ним будет на порядок меньше, чем к остальным.

Теперь, если Вы не обычный аналитик, а злоумышленник, Вы можете использовать уязвимость Spectre. Вы просите программу обратиться к памяти, которая Вам не доступна, процессор спекулятивно вычисляет результат, но не выдаёт его, потому что не Вам положено!! Однако при помощи timing attack можно понять, какая область памяти оказалась в кэшах в процессе спекулятивного исполнения, и достать недоступные данные по физическим адресам. Забавно, что это почти невозможно отследить.
