### greetings
Доброе утро! Сейчас речь пойдёт о так называемой атаке Spectre. Наверняка многие из Вас слышали о ней или о схожей атаке Meltdown. Spectre основан на некоторых уязвимостях в устройстве современных процессоров.

### agenda
Первая часть доклада будет содержать теоретическое объяснение этих уязвимостей. После чего будет небольшая демонстрация и пояснение кода. В самом конце, думаю, мы обсудим некоторые другие атаки, а также попытки их предотвратить. Для лучшего понимания давайте кратко рассмотрим основные концепции.

### structure
Для начала давайте посмотрим на вычислительную систему абстрактно. Задача любой вычислительной системы --- обработка данных. Эти самые данные нужно где-то хранить и, соответственно, обращаться к ним в случае надобности. Операции над этими данными производит процессор. Как вы знаете, процессор --- это мозг всех наших устройств. Процессор отвечает за выполнение всех инструкций, заданных программистом. И, конечно же, важным параметром процессора является скорость его работы.

Также важно сказать пару слов о памяти. В наших устройствах есть три типа памяти: диск, затем основная системная память, также называемая оперативной памятью, и, наконец, кэш-память в процессоре.

Для понимания сути демонстрируемой уязвимости этих знаний о процессоре будет достаточно, зато нелишним будет отметить некоторые особенности. Примечателен тот факт, что чем больше данных устройство хранит носитель, тем больше время доступа к этим самым данным. На текущий момент комплексам хорошо себя зарекомендовала иерархическая структура памяти. При таком построении данные хранятся преимущественно в большой и медленной памяти, "далекой" от процессора. При обращении к ним нужная часть переносится ближе к процессору и сохраняется в памяти, которая чуть быстрее и дороже. Этот процесс можно практически неограниченно продолжать, добавляя все более быструю память на верхушку иерархии и все более медленную --- в основу этой пирамиды.


### speed
Это была абстракция, но как на счет некоторой конкретики? Мы остановились на трехуровневой модели памяти. В порядке уменьшения времени доступа: диск, затем основная --- оперативна память, и кэш. На таблице представлены характерные времена операций, связанных с вводом-выводом данных, и некоторые сопутствующие операции, приведённые для сравнения. Обратите внимание, как растет время доступа с удалением от процессора.

Так как обращение к RAM на пару порядков больше типичного времени выполнения инструкции, люди добавили небольшой кэш (L1 и L2 в таблице) на кристалл процессора для очень быстрого доступа к данным, с которыми он работает в данный момент. Каждый раз, когда процессор что-то достаёт из основной памяти, он копирует это значение в кэш и в следующий раз прочитает информацию уже из кэша с большей скоростью.

### speculative execution
Вернемся к быстродействию. Стремясь улучшить скорость процессора, архитекторы процессоров однажды пришли к так назваемому "спекулятивному" исполнению. Что же это такое? Алгоритмы обработки данных редко бывают последовательными -- практически в любой программе можно встретить условные переходы: инструкции, которые необходимо исполнить далее, зависят от какого-то условия. Представьте, что у вас есть какое-то условие в коде, зависящее от данных, которые отстутствуют в кэшах. Процессор вынужден запросить эти данные из основной, медленной памяти. Однако вместо того чтобы ждать пока данные будут доставлены, процессор попытается угадать ветвь исполнения, основываясь на предыстории. Когда же данные придут из RAM, процессор может проверить, угадал ли он. Если да, то он "опередил себя" на сотню операций, если нет --- он "выбросит" полученный результат и пойдет по нужному пути, не сильно потеряв в производительности.

Прекрасная технология, но есть один нюанс. Спекулятивно вычисляя результат, процессор обращается к памяти, которая может быть недоступна пользователю при нормальном выполнении программы. Это открывает целый спектр атак типа Spectre.

### timing attack
Чуть подробнее расскажу о варианте, который был нами реализован.
Существует целый ряд аттак по стороннему каналу, при которых данные добываются при помощи наблюдений за поведением системы. В частности, нас будет интересовать так называемая timing attack, которая вместе со спектром образует опасное оружие. 

Представьте, что вы аналитик, который измеряет время доступа процессора к некоторой памяти. Как уже отмечалось, если процессор недавно уже обращался к запрашиваемому участку памяти, то данные будут храниться в кэше, значит время доступа к ним будет на порядок меньше, чем к остальным. Например, как на слайде, обратившись к 10 элементам массива, мы видим, что элементы 2 и 6 находятся в кэше, т.е. с ними недавно производились какие-то действия.

### basis
Давайте теперь мысленно построим базис атаки. Если Вы не обычный аналитик, а злоумышленник, Вы можете использовать уязвимость Spectre. Вы просите программу обратиться к памяти, которая Вам не доступна. Процессор спекулятивно исполняет какие-то инструкции, но не выдаёт их результат, потому что Вам положено они не предназначены!! Однако при помощи timing attack можно понять, какая область памяти оказалась в кэшах в течение спекулятивного исполнения, после чего можно достать недоступные ранее данные по их физическим адресам. 

### clint
Забавно, что это почти невозможно отследить и ни у кого нет никаких гарантий на безопасность при использовании современных архитектур. Подводя итог теоретической части, я бы хотел подчеркнуть оплошность, которая была допущена при создании архитектуры процессора. Наивно посчитав кэши прозрачными для программиста, разработчики позволили процу при спекулятивном выполнении обращаться в эти же самые кэши и, соответственно, оставлять следы своей незаконной деятельности.

### code
Передаю слово моему коллеге))))))))))))))))0


