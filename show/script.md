Доброе утро! Сейчас речь пойдёт о так называемой атаке Spectre. Наверняка многие из Вас слышали о ней или о схожей атаке Meltdown. Spectre основан на некоторых уязвимостях в устройстве современных процессоров.

Первая часть доклада будет содержать теоретическое объяснение этих уязвимостей. Во второй части будет небольшая демонстрация и пояснение кода. Для лучшего понимания давайте кратко рассмотрим основные концепции.

**Давайте посмотрим на вычислительную систему абстрактно. Задача любой вычислительной системы -- обработка данных. Эти самые данные надо где-то хранить и, соответственно, обращаться к ним в случае надобности. Операции над этими данными производит процессор.**

Как вы знаете, процессор - это мозг всех наших устройств.
Процессор отвечает за выполнение всех инструкций, которые даёт наша операционная система и наши программы**Мб "инструкций, описанных программистом"?**. И, конечно же, важным параметром процессора является скорость его работы.

Также важно сказать пару слов о памяти.
В наших устройствах есть два **три? еще диск, это в коде просвечивает тож** типа памяти: основная системная память, также называемая оперативной памятью, и кэш-память в процессоре. Работающему процессору необходимо постоянно считывать и записывать данные из основной памяти. **Вероятно, это может стриггерить на старую тему с перезаписью всей памяти, ибо кондеры разряжались.**

========
Мб стоит развить во что-то типа...

Для понимания сути демонстрируемой уязвимости этих знаний о процессоре будет достаточно, зато нелишним будет подробнее изучить устройтва памяти. Существует огромное число различных устройств хранения, каждое из которых характеризуется стоимостью, вместительностью, скоростью записи и доступа, энергопотреблением и множеством иных праметров, диктующих применимость устройтва в тех или иных условиях. Примечателен тот факт, что, как правило, чем больше данных устройство способно хранить, тем выше его стоимость и больше время доступа к этим самым данным. На текущий момент применительно к вычислительным комплексам хорошо себя зарекомендовала иерархическая структура памяти. При таком построении данные хранятся преимущественно в большой и медленной памяти, "далекой" от процессора. При обращении к ним нужная часть переносится ближе к процессору и сохраняется в памяти, которая чуть быстрее и дороже. Этот процесс можно практически неограниченно продолжать, добавляя все более быструю память на верхушку иерархии и все более медленную -- в основу этой пирамиды.

Описанный подход работает в силу так называемого "принципа локальности". Большинство программ не оперируют со всеми доступными им данными одновременно -- обычно программа работает с некоторым подмножеством данных, и затем переходит к другому подмножеству. Это позволяет "загрузить" необходимый кусок данных в быструю, но маленькую память, и работать с ними быстрее, чем обращясь напрямую к медленную память. В целом это збс и работает. А еще это порочный круг -- из-за проги делают кэши, а из-за кэшей пишут кэш-френдли проги.

Это была абстракция, что на счет некоторой конкретики? Мы остановимся на трехуровневой модели памяти -- просто будем игнорировать несущественные детали. В порядке уменьшения времени доступа: диск, затем основная - оперативна - память, и затем кэш. На картинке представлены характерные времена операций, связанных с вводом-выводом данных, и некоторые сопутствующие операции, которые пока не представляют такого интереса. Обратите внимание, как растет время доступа с увеличением объема памяти.

========

*Однако обращение к RAM намного медленнее, чем скорость процессора, поэтому люди добавили небольшой кэш на сам процессор* **Так как обращение к RAM на пару порядков больше типичного времени выполнения инструкции, люди добавили небольшой кэш (L1 и L2 на картинке) на кристалл процессора** для очень быстрого доступа к данным, с которыми он работает в данный момент. Каждый раз, когда процессор что-то достаёт из основной памяти, он копирует это значение в кэш и в следующий раз прочитает информацию уже из кэша с большей скоростью.

**Вернемся к быстродействию.**
Стремясь улучшить быстродействие процессора, архитекторы процессоров однажды пришли к так назваемому "спекулятивному" исполнению. Что же это такое? **Алгоритмы обработки данных редко бывают последовательными -- практически в любой программе можно встретить условные переходы: инструкции, которые необходимо исполнить далее, зависят от какого-то условия.** Представьте, что у вас есть какое-то условие в коде, зависящее от данных, которые отстутствуют в кэшах.(todo**смею продолжить**)**Процессор вынужден запросить эти данные из основной, медленной памяти. Однако** Вместо того чтобы ждать *долгого обращения к основной памяти* **, пока данные будут доставлены**, процессор *попытается наперёд произвести операцию, которая стоит под условием* **может попытаться угадать ветвь исполнения, основываясь на предыстории**. *После чего получит результат условия и, в зависимости от него, отбросит или сохранит уже вычисленный результат.* **Когда же данные придут из RAM, процессор может проверить, угадал ли он. Если да, то он "опередил себя" на сотню операций, если нет -- он "выбросит" полученный результат и пойдет по нужному пути, эффективно не объебавшись.**

Прекрасная технология, но есть один нюанс. Спекулятивно вычисляя результат, процессор *на hardware уровне -- формально проц все делает на hw-уровне))* обращается к памяти, которая может быть недоступна *со стороны софта* **пользователю/программисту мб? при нормальном выполнении программы**. Это открывает целый спектр атак типа Spectre.

Чуть подробнее расскажу о варианте, который был нами реализован.
Существует **целый букет аттак по стороннему каналу, при которых данные добываются при помощи наблюдений за поведением системы. В частности, нас будет интересовать **так называемая timing attack, которая вместе со спектром образует опасное оружие. 

Представьте, что вы аналитик, который измеряет время доступа процессора к некоторой памяти. Как уже отмечалось, если процессор недавно уже обращался к запрашиваемому участку памяти, то данные будут храниться в кэше, значит время доступа к ним будет на порядок меньше, чем к остальным.

Теперь, если Вы не обычный аналитик, а злоумышленник, Вы можете использовать уязвимость Spectre. Вы просите программу обратиться к памяти, которая Вам не доступна, процессор спекулятивно вычисляет результат, но не выдаёт его, потому что не Вам положено!! Однако при помощи timing attack можно понять, какая область памяти оказалась в кэшах в процессе спекулятивного исполнения, и достать недоступные данные по физическим адресам. Забавно, что это почти невозможно отследить.
