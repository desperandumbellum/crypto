
1. Обзор всего эксперимента
    Есть tcp-сервер, который мы хотим атаковать, а именно украсть некоторый секрет, с которым данный процесс был запущен. На той же машине, что и сервер, запущен атакующий процесс, никак явно не общающийся с сервером. Третий процесс, участвующий в атаке - это наш коварный клиент, подсовывающий серверу правильно подобранные данные и синхронизирующий действия атакующего процесса.
    Таким образом, мы производим управление атакой, ипользуя лишь один процесс, который, вообще говоря, может находиться на удаленной машине.

2. Демонстрация
    Запустим все процессы. Пока поверьте мне на слово: в память, где находится секрет, обратиться нельзя. Пароль записывается однажды и больше обращений к этой памяти не производится. Для удобства адрес этой памяти выводится сервером. Итак, можно определить, что пароль находится на 96 байтов "левее" опорного массива. Давайте используем это смещение и убедимся, что мы можем прочитать данные, находящиеся в "закрытой" памяти. Ура, получилось. Двигаясь далее, можно прочитать пароль целиком.

3. victim code
    Теперь посмотрим, за счет чего выполняется атака. Для этого пробежимся по коду сервера и я обращу внимание на основные моменты. Сразу давайте перейдем к самой важной и горячей части, которая стала символом атаки. Это функция victim. Что в ней происходит? Здесь процесс проверяет, лежит ли аргумент x в допустимых рамках и, если все хорошо, использует данные из массива nums для индексации по второму массиву. Здесь важно понимать, что представляет из себя обращение к массиву с точки зрения процессора. Для того, чтобы обратиться с i-му элементу массива nums, нужно знать адрес начала массива и смещение относительно этого начала в байтах. Соответственно, зная адрес секретного байта secret, мы можем указать смещение (secret - nums) и обратиться к секретному байту.
    К счастью, мы не можем так сделать. Любая попытка вызвать функцию с индексом, большим, чем size, и тем более меньшим нуля, не увенчается успехом - у нас имеется проверка. Или увенчается?..

4. Speculative execution
    Как только что отметил мой коллега, процессоры могут в спекулятивное выполнение кода. В частности, если несколько раз вызвать эту функцию с коррестными смещениями, затем "спрятать" параметр size и вызвать функцию с некорретным смещением, то, пока выполняется запрос к памяти, процессор может предположить, что вызов и на этот раз будет успешным и исполнить код. Позже процессор поймет, что ошибся, выбросит результаты и пойдет по нужному пути, оставив следы в кэшах. В частности, в кэшах окажется значение из массива array, расположенное на смещении, определяемом секретным байтом.
    Задачей атакующего процесса остается определить это смещение и, зная его, вычислить значение секретного байта.

5. General server overview
    Давайте тогда завершим обзор сервера. В начале он производит некоторые настройки, не связанные с атакой и бизнес-логикой. В частности, считывает секрет. Затем принимает соединение и обрабатывает его следующим образом. Сервер принимат массив индексов и вызывает свою функцию "обработки" с этими индексами. Затем мы вызываем _cl_flush() - функцию, вычищающую заданный адрес из кеша. Это легальное допущение, поскольку спесобов избавиться от кеш-линии существует много и мы лишь упростили этот процесс для наглядности. Затем функция вызывается с последним аргументом, куда мы можем подложить желаемое смещение.

6. attacker
    Что ж, теперь перейдем к самому вкусному - к атакующему процессу. Этот процесс замеряет обращения к памяти сервера, а именно к определенным частям массива array. В силу различных неоднородностей в работе процесса, стоит повторить атаку на конкретный байт несколько раз, чтобы надежно узнать его значение. Собрав статистику, мы выбираем байт, который чаще всех оказывался в кэше.
    Отдельным вопросом является задача доступа к этому самому массиву. На уровне операционной системы происходит разделение памяти различных процессов за счет введения виртуальной памяти, так что один и тот же адрес в разных процессах может, и скорее всего будет, ссылаться на разные данные. Обойти это позволяет возможность отображения файлов в память процесса и технология copy-on-write. В целях экономии дорогой оперативной памяти операционная система может отображать один и тот же физический адрес в адресные пространства различных процессов. При записи в эту область физическая памяти страница памяти дублируется и виртуальные адреса начинают ссылаться на различные физические участки памяти. В нашем случае в массив array записей не производится, поэтому мы можем найти его в бинарнике сервера и отобразить в свое адресное пространство.
    Несмотря на то, что это действие может показаться сомнительным, оно вполне имеет место быть в реальности. Для примера, исполняемые файлы сервисов в *NIX-системах доступны на чтение любому пользователю, не смотря на то, что они принадлежат пользователю root, и этого достаточно для проведения атаки таким образом. В частности, мы производим no-pie сборку для упрощения процесса поиска адреса массива. В таком случае ASLR не вступает в силу: компилятор генерирует position-dependent код, что позволяет ему использовать rip-относительную адресацию и абсолютные виртуальные адреса. Поэтому мы можем довольно дешево распарсить эльф: прочитать заголовок эльфа, определить смещение заголовков секций, найти .symtab и оттуда выйти на адрес нужного символа. Так как мы ставим перед собой лишь задачу демонстрации атаки, а не написание фреймворка, мы пошли дальше и поместили массив array в кастомную секцию, что позволило нам сэкономить один шаг, не ограничив общности.
