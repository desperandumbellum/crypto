
1. Обзор всего эксперимента
    Есть tcp-сервер, который мы хотим атаковать, а именно украсть некоторый секрет, с которым данный процесс был запущен. Можете думать, что это пароль или данные вашей кредитки. На той же машине, что и сервер, запущен атакующий процесс, никак явно не общающийся с сервером. Третий процесс, участвующий в атаке --- это наш коварный клиент, подсовывающий серверу правильно подобранные данные и синхронизирующий действия атакующего процесса.
    Таким образом, мы производим управление атакой, ипользуя лишь один процесс, который, вообще говоря, может находиться на удаленной машине.

2. Демонстрация
    Запустим все процессы. Пока поверьте мне на слово: в память, где находится секрет, нельзя обратиться никому кроме сервера. Пароль записывается однажды и больше обращений к этой памяти не производится. Для удобства адрес этой памяти выводится сервером. Однако именно при помощи Spectre и Timing Attack вне сервера можно определить, что находится за пределами опорного массива. Нужное смещение можно найти перебором, это не является основой атаки, поэтому пока мы можем просто вывести адреса секрета и опорного массива. Давайте используем это смещение и убедимся, что мы можем прочитать данные, находящиеся в "закрытой" памяти. Ура, получилось. Двигаясь далее, можно прочитать пароль целиком.

3. victim code
    Теперь посмотрим, за счет чего выполняется атака. Для этого пробежимся по коду сервера и я обращу внимание на основные моменты. Давайте перейдем к самой важной и горячей части, которая стала символом атаки. Это функция `victim`. Что в ней происходит? Здесь процесс проверяет, лежит ли аргумент x в допустимых рамках и, если все хорошо, использует данные из массива nums для индексации по второму массиву. Здесь важно понимать, что представляет из себя обращение к массиву с точки зрения процессора. Для того, чтобы обратиться с i-му элементу массива `nums`, нужно знать адрес начала массива и смещение относительно этого начала в байтах. Соответственно, зная адрес секретного байта secret, мы можем указать смещение (`secret - nums`) и обратиться к секретному байту.
    К счастью, мы не можем так сделать. Любая попытка вызвать функцию с индексом, большим, чем `size`, и тем более меньшим нуля, не увенчается успехом - у нас имеется проверка. Или увенчается?..

4. Speculative execution
    Как только что отметил мой коллега, процессоры могут в спекулятивное выполнение кода. В частности, если несколько раз вызвать эту функцию с корректными смещениями, а затем "спрятать" параметр `size` и вызвать функцию с некорретным смещением, то, пока выполняется запрос к памяти, процессор предположит, что вызов и на этот раз будет успешным и исполнит код. Позже процессор поймет, что ошибся, выбросит результаты и пойдет по нужному пути, но оставит следы в кэшах и будет уже поздно. В частности, в кэшах окажется значение из массива `array`, расположенное на смещении, определяемом секретным байтом.
    Задачей атакующего процесса остается определить это смещение и, зная его, вычислить значение секретного байта.

5. General server overview
    Давайте тогда завершим обзор сервера. В начале он производит некоторые настройки, не связанные с атакой и бизнес-логикой *wat*. В частности, считывает секрет. Затем принимает соединение и обрабатывает его следующим образом. Сервер принимат массив индексов и вызывает свою функцию "обработки" с этими индексами. Затем мы вызываем `_mm_clflush()` --- функцию, вычищающую заданный адрес из кеша. Это легальное допущение, поскольку способов избавиться от кеш-линии существует много и мы лишь незначительно упростили этот процесс для наглядности. Затем функция вызывается с последним аргументом, куда мы можем подложить желаемое смещение.

6. attacker
    Что ж, теперь перейдем к самому вкусному --- к атакующему процессу. Этот процесс замеряет обращения к памяти сервера, а именно к определенным частям массива `array`. В силу различных неоднородностей в работе процесса, стоит повторить атаку на конкретный байт несколько раз, чтобы надежно узнать его значение. Собрав статистику, мы выбираем байт, который наиболее вероятно в кэше.
    Отдельным вопросом является задача доступа к этому самому массиву. На уровне операционной системы происходит разделение памяти различных процессов за счет введения виртуальной памяти, так что один и тот же адрес в разных процессах может, и скорее всего будет, ссылаться на разные данные. Обойти это позволяет возможность отображения файлов в память процесса и технология copy-on-write. В целях экономии дорогой оперативной памяти операционная система может отображать один и тот же физический адрес в адресные пространства различных процессов. При записи в эту область физическая памяти страница памяти дублируется и виртуальные адреса начинают ссылаться на различные физические участки памяти. В нашем случае в массив `array` записей не производится, поэтому мы можем найти его в бинарнике сервера и отобразить в свое адресное пространство.

	Несмотря на то, что отображение части исходного файла в свое адресное пространство может показаться "игрушечным" проведением атаки, смею Вас заверить, что это не так. Для примера, исполняемые файлы сервисов в *NIX-системах доступны на чтение любому пользователю, и это позволяет поступить с ними тем же образом. И даже не технологии вроде ASLR, address space layout randomization, лишь усложняет процесс поиска, но не делает его невозможным. Для конкретики, в *NIX можно прочитать память практически любого процесса обратившись в директорию /proci/[pid]/map_files/ или прочитав /proc/[pid]/mem. Итак, на данный момент мы производим no-pie сборку для небольшого упрощения процесса поиска адреса массива, иначе мы убьём вас способами обхода ASLR. Как результат, мы можем довольно дешево распарсить бинарный файл сервера: прочитать заголовок, определить смещение заголовков секций, найти секцию .symtab и оттуда выйти на адрес нужного символа. Так как мы ставим перед собой задачу демонстрации атаки, а не написание полноценного фреймворка, мы пошли дальше и поместили массив `array` в кастомную секцию не ограничив общности.
